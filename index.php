<?php
define ( 'PATCH_LOCATION', 'patch/patch.patch' );
define ( 'ORIGINAL_LOCATION', 'original/' );

$gen = new VQModGenerator();
$gen->parsePatch(PATCH_LOCATION);
$gen->generateVqmodXML();
$gen->xmlToScreen();

class VQModGenerator extends stdClass 
{
	private $patchArray;
	private $patchSource;
	private $outputName;
	private $xml;
	private $fails;
	public function __construct() 
	{
		$this->patchArray = array();
		$this->patchSource = NULL;
		$this->fails = array();
		$this->outputName = 'output.xml';
	}
	public function xmlToScreen()
	{
		$fp = fopen($this->outputName, 'rb');
		// send the right headers
		header("Content-Type: text/xml");
		header("Content-Length: " . filesize($this->outputName));
		// dump the file and stop the script
		fpassthru($fp);
		exit;
	}
	public function generateVqmodXML()
	{
		if (!$this->patchArray || sizeof($this->patchArray) < 1) return false;
		$this->xml = new SimpleXMLExtended('<!-- Generated by SubVQMod - DNC Solutions 2014 http://dannicholson.co.uk/projects/subvqmod--><modification></modification>');
		$x = $this->xml->addChild('id');
		$x->addCData('Describe your mod');
		$x = $this->xml->addChild('version');
		$x->addCData('1.00');
		$x = $this->xml->addChild('vqmver');
		$x->addCData('2.3.2');
		$x = $this->xml->addChild('author');
		$x->addCData('Your name here');
		
		
		foreach($this->patchArray as $filename => $file)
		{
			$f = $this->_addFile($filename);
			foreach($file as $opid => $op)
			{
				$this->_addOperation($op, $f);
			}
		}
		$this->xml->asXML($this->outputName);
		
		if(sizeof($this->fails) > 0)
		{
			echo '<p>There were problems generating XML for the following operations, the file as still been generated.';
			var_dump($this->fails);
			die();
		}
	}
	
	private function _addFile($path)
	{
		$file = $this->xml->addChild('file');
		$file->addAttribute('name', $path);
		$file->addAttribute('error', 'abort');
		return $file;
	}
	private function _addOperation($operation, $ref)
	{
		if (!isset($operation['find'])) return null;
		$op = $ref->addChild('operation');
		//$op->addAttribute('name', $path);
		$op->addAttribute('error', 'abort');
		$op->addAttribute('info', '');
		
		// Add search element
		$search = $op->addChild('search');
		$search->addCData($operation['find']);
		$search->addAttribute('position', $operation['method']);
		
		if (isset($operation['offset']) && $operation['offset']) $search->addAttribute('offset', abs($operation['offset']));
		
		$search = $op->addChild('add');
		$search->addCData(implode("\n",$operation['add']));
		
		//var_dump($operation);
		return $op;
	}
	
	public function parsePatch($filename) {
		
		$handle = @fopen ($filename, "r" );
		$contents = array ();
		$fnme = '';
		if ($handle) {
			while ( ($file = fgets ( $handle, 4096 )) !== false ) {
				if (strpos ( $file, 'Index: ' ) !== FALSE) {
					$fnme = trim ( str_replace ( 'Index: ', '', $file ) );
					continue;
				}
				$contents [$fnme] [] = $file;
			}
			if (! feof ( $handle )) {
				echo "Error: unexpected fgets() fail\n";
			}
			$this->patchSource = $contents;
			fclose ( $handle );
			$files = array ();
			$opcount = 0;
			foreach ( $contents as $fname => $file ) {
				for($i = 0; $i < sizeof ( $file ); $i ++) {
					// Ignore this and the next two lines
					if (strpos ( $file [$i], '===============' ) === 0) {
						$i += 2; // skip two lines
						continue;
					}
					// Trigger new operation
					if (strpos ( $file [$i], '@@ ' ) === 0) {
						
						$opcount ++;
						$files [$fname] [$opcount] ['lnum'] = abs((int)substr($file[$i],3,strpos($file[$i],',')-3));
						continue;
					}
					// Add line to operation array
					$files [$fname] [$opcount] ['lines'] [] = trim ( $file [$i] );
				}
			}
			
			foreach ( $files as $fname => $file ) {
				// For each operation, work out find string and replace line(s). Also work out method (replace / after).
				foreach ( $file as $opid => $op ) {
					foreach ( $op ['lines'] as $opline => $line ) {
						// Found replacement / new line
						if ($pos = strpos ( $line, '+' ) === 0) {
							if (! isset ( $files [$fname] [$opid] ['find'] )) {
								if (isset ( $op ['lines'] [$opline - 1] )) {
									$files [$fname] [$opid] = $this->_getFind($fname, $op['lines'], $opline-1, $op['lnum']);
									if (!$files [$fname] [$opid]) 
									{
										unset($files [$fname] [$opid]);
										$this->fails[$fname][] = $op;
										continue;
									}
									$files [$fname] [$opid]['offset'] -= ($opline-1);
									// If line before is '-' in patch, mark as replacement rather than 'after'.
									if(strpos($op['lines'][$opline-1], '-') === 0) $files [$fname] [$opid]['method'] = 'replace';
								}
							}
							$ln = substr ( $line, 1 );
							if ($files [$fname] [$opid] ['method'] == 'replace')
								$ln = trim ( $ln );
							$files [$fname] [$opid] ['add'] [] = $ln;
						}
					}
				}
			}
		}
		$this->patchArray = $files;
		return $files;
	}
	/**
	 * Get Find String From Patch
	 * @param str $file Filename and path
	 * @param array $lines Patch change lines
	 * @param int $line Current line number for search
	 * @param int $lnum Change location within file
	 * @param string $searchUp Direction of search
	 * @return array Find element
	 */
	private function _getFind($file, $lines, $line, $lnum, $searchUp = FALSE)
	{
		$find = array('method' => 'after', 'find' => NULL,'offset' => NULL);
		$contents = file_get_contents(ORIGINAL_LOCATION . $file);
		
		// Do search if line is not empty
		if (trim($lines[$line]) != '') 
		{
			$ln = '';
			if (strpos($lines[$line], '-') === 0)
			{
				$ln = trim(substr($lines[$line],1));
			}
			else $ln =  trim($lines[$line]);
			$cnt = substr_count($contents, $ln);
			if ($cnt == 1) 
			{
				$find['find'] = $ln;
				$find['offset'] = $line;
				//var_dump('found', $find);
				return $find;
			}
		}
		
		// Increment / Decrement search position
		if ($searchUp) $line++;
		else $line--;
		
		// No more lines left, go to the file
		if(!isset($lines[$line]))
		{
			$cont_lines = explode("\n",$contents);
			//var_dump('not found in patch', $file, $lines);
			$find = $this->_getFindByFile($contents, $cont_lines, $lnum+$line, $searchUp);
			// Search in the other direction
			if (!$find) return $this->_getFind($file, $lines, $line, $lnum, TRUE);
			return $find;
		}
		
		return $this->_getFind($file, $lines, $line, $lnum);
	}
	private function _getFindByFile($contents, $cont_lines, $line, $searchUp)
	{
		$find = array('method' => 'after', 'find' => NULL,'offset' => NULL);
		if ($searchUp)
		{
			for($i = ($line+1); $i < sizeof($cont_lines); $i++)
			{
				$f = trim($cont_lines[$i]);
				if ($f == '') continue;
				$cnt = substr_count($contents, $f);
				if ($cnt == 1)
				{ 
					//echo 'found on ' . $i . ': '.$f.'<br />';
					$find['offset'] = ((int)$i-(int)$line); 
					$find['find'] = $f;
					//var_dump('found in file', $i, $line, $find);
					return $find;
				}
			}
		}
		else
		{
			for($i = ($line-1); $i > 0; $i--)
			{
				//var_dump($i);
				$f = trim($cont_lines[$i]);
				if ($f == '') continue;
				$cnt = substr_count($contents, $f);
				if ($cnt == 1)
				{ 
					
					//echo 'found on ' . $i . ': '.$f.'<br />';
					$find['offset'] = ((int)$i-(int)$line); 
					$find['find'] = $f;
					//var_dump('found in file', $i, $line, $find);
					return $find;
				}
			}
		}
		return false;
	}
}
class SimpleXMLExtended extends SimpleXMLElement {
	public function addCData($cdata_text) {
		$node = dom_import_simplexml($this);
		$no   = $node->ownerDocument;
		$node->appendChild($no->createCDATASection($cdata_text));
	}
}
