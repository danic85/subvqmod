<?php 

require_once('SimpleXMLExtended.php');

/**
 * @package SubVQMod
 * @version 0.1.1
 * @author Dan Nicholson
 * @license https://github.com/danic85/subvqmod/blob/master/LICENSE - MIT Licence (MIT)
 * @link   http://dannicholson.co.uk/projects
*/
class SubVQModGenerator extends stdClass
{
	private $patchArray;
	private $outputName;
	private $xml;
	private $fails;
	public function __construct($output = "output.xml")
	{
		$this->patchArray = array();
		$this->fails = array();
		$this->outputName = $output;
	}
	
	/**
	 * Output generated XML file to browser
	 */
	public function xmlToScreen()
	{
		$fp = fopen($this->outputName, 'rb');
		// send the right headers
		header("Content-Type: text/xml");
		header("Content-Length: " . filesize($this->outputName));
		// dump the file and stop the script
		fpassthru($fp);
		exit;
	}
	
	/**
	 * Generate VQMod XML file from parsed data
	 * @return boolean Success
	 */
	public function generateVQModXML()
	{
		if (!$this->patchArray || sizeof($this->patchArray) < 1) throw new Exception("Patch file has not been parsed correctly.");

		$this->xml = new SimpleXMLExtended('<!-- Generated by SubVQMod - DNC Solutions 2014 http://dannicholson.co.uk/projects/subvqmod--><modification></modification>');
		$x = $this->xml->addChild('id');
		$x->addCData('Describe your mod');
		$x = $this->xml->addChild('version');
		$x->addCData('1.00');
		$x = $this->xml->addChild('vqmver');
		$x->addCData('2.3.2');
		$x = $this->xml->addChild('author');
		$x->addCData('Your name here');

		foreach($this->patchArray as $filename => $file)
		{
			$f = $this->_addFile($filename);
			foreach($file as $opid => $op)
			{
				$this->_addOperation($op, $f);
			}
		}
		$this->xml->asXML($this->outputName);

		if(sizeof($this->fails) > 0) return false;
		return true;
	}

	/**
	 * If fail array is not empty, display and return true
	 * @return boolean
	 */
	public function displayFails()
	{
		if(sizeof($this->fails) > 0)
		{
			echo '<p>There were problems generating XML for the following operations, the file as still been generated.';
			var_dump($this->fails);
			return true;
		}
		return false;
	}

	/**
	 * Add file element to XML with name and error attributes
	 * @param string $path File path and name
	 * @return SimpleXMLElement
	 */
	private function _addFile($path)
	{
		$file = $this->xml->addChild('file');
		$file->addAttribute('name', $path);
		$file->addAttribute('error', 'abort');
		return $file;
	}

	/**
	 * Add operation element to XML, add search element to operation.
	 * @param array $operation Operation data
	 * @param array $ref XML element reference
	 * @return SimpleXMLElement
	 */
	private function _addOperation($operation, $ref)
	{
		if (!isset($operation['anchor'])) throw new Exception("Find operation is not defined");
		
		
		$op = $ref->addChild('operation');
		//$op->addAttribute('name', $path);
		$op->addAttribute('error', 'abort');
		$op->addAttribute('info', '');

		// Add search element
		$search = $op->addChild('search');
		
		//@todo make this work with complex operations
		
		$start = $operation['anchor'] - ($operation['start']-1);
		$offset = abs(($start+1) - $operation['change'][0]['line']);
		if ($operation['method'] == 'replace') $offset--;
		$add = array();
		$remove = array();
		foreach($operation['lines'] as $line => $l)
		{
			$found = false;
			foreach($operation['change'] as $change)
			{
				if ($change['operation'] == '-' && $change['line'] == $line)
				{
					$remove[] = $operation['lines'][$line];
					$found = true;
				}
				else if ($change['operation'] == '+' && $change['line'] == $line)
				{
					$add[] = $operation['lines'][$line];
					$found = true;
				}
				if ($found) break;
			}
			if (!$found && $offset && $operation['method'] == 'replace' && $start == 0) $add[] = $operation['lines'][$line];
				
		}
		if (sizeof($remove) > 1) $this->fails[] = $operation;
		$offset += sizeof($remove)-1;
		//var_dump($add);
				
		$search->addCData(trim($operation['lines'][($start < 0 ? 0 : $start)]));
		$search->addAttribute('position', $operation['method']);
		
		if (sizeof($operation['change']) > 0)
		{
			if ($offset) $search->addAttribute('offset', $offset);
		}
		
		$search = $op->addChild('add');
		$search->addCData(implode("\n", $add));
		
		return $op;
	}
	
	public function parsePatches($folder)
	{
		if ($handle = opendir($folder)) 
		{
			while (false !== ($filename = readdir($handle))) {
				if (strpos($filename, '.patch') !== FALSE)	{
					$this->parsePatch($folder.'/'.$filename);
				}
			}
			closedir($handle);
		}
		return true;
		//var_dump($this->patchArray);
	}

	/**
	 * Parse subversion patch file
	 * @param string $filename
	 * @return boolean Success
	 */
	public function parsePatch($filename) {

		$handle = @fopen ($filename, "r" );
		$ops = array();
		$opcnt = 0;
		if ($handle) {
			// Get patch file one line at a time
			while ( ($file = fgets ( $handle, 4096 )) !== false ) {
				// Get name of file operations will be carried out on
				if (strpos ( $file, 'Index: ' ) === 0) {
					$fnme = trim ( str_replace ( 'Index: ', '', $file ) );
					continue;
				}
				// Ignore useless lines
				if (strpos($file, '====') === 0 || strpos($file, '---') === 0 || strpos($file, '+++') === 0) {
					continue;
				}
				if (strpos ( $file, '@@' ) === 0) {
					$opcnt++;
					$ops[$fnme][$opcnt]['start'] = abs((int)substr($file,3,strpos($file,',')-3));
					continue;
				}
				//substr($lines[$line],1));
				
				
				if (strpos ( $file, '+' ) === 0) {
					$ops[$fnme][$opcnt]['change'][] = array('operation' => '+', 'line' => sizeof($ops[$fnme][$opcnt]['lines']));
					$ops[$fnme][$opcnt]['lines'][] = rtrim(substr($file,1));
				}
				else if (strpos ( $file, '-' ) === 0) {
					$ops[$fnme][$opcnt]['change'][] = array('operation' => '-', 'line' => sizeof($ops[$fnme][$opcnt]['lines']));
					$ops[$fnme][$opcnt]['lines'][] = rtrim(substr($file,1));
				}
				else $ops[$fnme][$opcnt]['lines'][] = rtrim($file);
				
			}
			$this->_parseOperations($ops);
			if (! feof ( $handle )) {
				throw new exception("Error: unexpected fgets() fail");
			}
			fclose ( $handle );
		}
		return true;
	}
	private function _parseOperations($files)
	{
		foreach($files as $fname => $ops)
		{
			$contents = @file_get_contents(ORIGINAL_LOCATION . $fname);
			if ($contents === FALSE) throw new Exception("Unable to open original file for _getFind(): " . ORIGINAL_LOCATION . $fname);
			$lines = explode("\n",$contents);
			
			foreach($ops as $opid => $op)
			{
				$files[$fname][$opid]['method'] = 'after';
				
				// Set start pos (position of first element (-1 for array find)
				$s = $op['start']-1;
				// Incorporate line of first change
				if (sizeof($op['change']) > 0) $s += ($op['change'][0]['operation'] == '-' ? $op['change'][0]['line'] : $op['change'][0]['line']-1); //@todo if add, start with line before.
				
				for($i = $s; $i > 0; $i--)
				{
					if (!trim($lines[$i])) continue;
					$cnt = substr_count($contents, trim($lines[$i]));
					if ($cnt == 1)
					{
						$files[$fname][$opid]['anchor'] = $i;
						break;
					}
				}
				
				// This searches up the file, @todo as it will need to be handled in_pushReplaceLines()
				/*if (!isset($files[$fname][$opid]['anchor']))
				{
					$files[$fname][$opid]['method'] = 'before';
					for($i = $s; $i < sizeof($lines); $i++)
					{
						$cnt = substr_count($contents, trim($lines[$i]));
						if ($cnt == 1)
						{
							$files[$fname][$opid]['anchor'] = $i;
							break;
						}
					}
				}*/
				if (!isset($files[$fname][$opid]['anchor'])) throw new Exception("Couldn't find anchor for: ". $opid ." in " . $fname);
				
				
				// Set method as replace if needed, and pad operation $lines if anchor is further back in the file.
				$lastadd = false;
				foreach($op['change'] as $id => $change)
				{
					if ($change['operation'] == '+')
					{
						if ($lastadd !== FALSE && $lastadd < ($change['line']-1))
						{
							$files[$fname][$opid]['method'] = 'replace';
							if ($files[$fname][$opid]['anchor'] - ($files[$fname][$opid]['start']-1) < 0)
							{
								$files = $this->_pushReplaceLines($files, $fname, $opid, $lines);
							}
							break;
								
						}
						else $lastadd = $change['line'];
					}
					else if ($change['operation'] == '-')
					{
						$files[$fname][$opid]['method'] = 'replace';
						if ($files[$fname][$opid]['anchor'] - ($files[$fname][$opid]['start']-1) < 0) 
						{
							$files = $this->_pushReplaceLines($files, $fname, $opid, $lines);
						}
						break;
					}
				}
				//if ($files[$fname][$opid]['anchor'] - ($files[$fname][$opid]['start']-1) < 0 && $files[$fname][$opid]['method'] == 'replace') echo 'REPLACE ME';
				//var_dump($files[$fname][$opid]['anchor'] - ($files[$fname][$opid]['start']-1), $fname, $files[$fname][$opid], trim($lines[$files[$fname][$opid]['anchor']]), '==============');
			}
		}
		$this->patchArray = $files;
	}
	/**
	 * If the replace involves an offset, we need to add the lines that will be replaced.
	 * @param array $files
	 * @param string $fname
	 * @param integer $opid
	 * @param array $lines
	 */
	private function _pushReplaceLines($files, $fname, $opid, $lines)
	{
		for($i = ($files[$fname][$opid]['start']-2); $i >= $files[$fname][$opid]['anchor']; $i--)
		{
			// push to front of array
			array_unshift($files[$fname][$opid]['lines'], rtrim($lines[$i]));
		}
		return $files;
	}
}
